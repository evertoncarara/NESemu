#include <iostream>
#include "MemorySystem.h"
#include "MOS6502.h"
#include "PictureProcessingUnit.h"
#include "UserInput.h"

#include <SDL.h> 

using namespace std;


int main(int argc, char *argv[]) {   
    
    if (argc < 2) {

        cout << "Syntax: " << argv[0] << " <rom_file>" << endl;
        return -1;
    }

    /* NES components */ 
    MOS6502 cpu;
    PictureProcessingUnit ppu;
    MemorySystem memorySystem;
    UserInput userInput;
    union Joystick joystick1;
    
    /* Components inicialization */
    memorySystem.Load(argv[1]); // Load PRG-ROM and CHR-ROM (if any)
    memorySystem.Init(&ppu);    // PPU registers access controlled by the memory system

    ppu.Init(&memorySystem);
    ppu.Reset();

    cpu.Init(&memorySystem);
    cpu.Reset();

    userInput.Init(&memorySystem,&joystick1);

    //int interruptPeriod = 27507;
    int interruptPeriod = 29760;    // ok segundo 1.Branch_Basics.nes
    int cpuCycles = interruptPeriod;

    /* Emulator main loop */
    for (;;) {
        
        /**
         *  341 pixels are rendered per scanline (although only 256 are displayed)
         *  Scanlines per frame (of which is V-Blank): 312 (70)
         *      312-70 = 242 scanlines/interruption
         *      242*341 = 82522 pixels/screen
         *      70*341 = 23870 pixels/vblank
         *  The PPU renders 3 pixels in one CPU clock
         *      82522/3 = 27507,3333 CPU cycles/screen
         *      23870/3 = 7956,66667 CPU cycles/vblank
         */
         cpuCycles -= cpu.ExecuteInstruction(); 

         if (cpuCycles <= 0) {
            ppu.Execute();

            /**
            *  NMI (Non-Maskable Interrupt) is the type of interrupt generated by the PPU when V-Blank occurs at the end of each frame. 
            *  Triggering of a NMI can be prevented if bit 7 of PPU Control Register ($2000) is clear.
            */
            if (ppu.GetVBlankInterruptEnable()==1)
                cpu.NMI();
            
            cpuCycles += interruptPeriod;

            if (userInput.Read() == 0)
                break;
        }           
    }
    return 0;
}
